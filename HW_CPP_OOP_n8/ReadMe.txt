Пояснение к заданию на создание параметрического динамического массива, принимающего любые типы.
1. Реализация функций параметризированного класса возможна только в месте объявления класса, т.е. в хедере. Как обойти это ограничение, найти не удалось.
2. Вначале был создан класс Array для проверки логики и работоспособности функций с типом int.{ЗАРАБОТАЛО}. При оценке работы класса выяснилось, что при изменении размера массива требуется, нередко, удалять и создавать внутрений массив ( data=new int[size] и delete[] data) при этом копировать элементы int из одного в другой.{НОРМАЛЬНОЕ ЯВЛЕНИЕ}
3. Затем была попытка создать класс ArrayT, полный аналог Array, но параметрический. Т.е. аналогично new char[size], new double[size] {НОРМАЛЬНО}. Но new TestClass[size] , если char занимает 1B, а TestClass (допустим) - 1kB, то массив из 1М элементов займет 1MB и 1GB соответвенно, можно ли выделить 1GB непрерывной ОЗУ? {ПРОБЛЕМАТИЧНО}. Кроме того при создании/удалении массива будут срабатывать конструкторы/деструкторы. {ОТНИМАЕТ СТЕК И ПРОЦЕССОРНОЕ ВРЕМЯ} В копировании большого числа объектов, а не указателей на них, из массива в массив тоже ничего хорошего.{РАБОТАЕТ, ОН НЕ ПОДХОДИТ}
4. Следующим был рассмотрен случай, когда массив хранит не объекты, а указатели на них. При создании/удалении массива мы имеем дело только с указателями. При копировании копируются только указатели. Конструктор срабатывает, только при добавлении объекта в массив (объект создается, но массив хранит только указатель), деструктор срабатывает при удалении массива Array или срабатывании методов setSize и removeAll, а ни при каждом изменение размера внутреннего массива, например при его заполнении. {ХОРОШО}. А как же базовые типы? Допустим нужен массив char. data будет хранить указатели на char, по 4B каждый. т.е. для хранения строки в 1kB нам потребуется 5kB.Т.е. эффективность использования память 20%.{РАБОТАЕТ НО С БАЗОВЫМИ ТИПАМИ МАЛОЭФФЕКТИВЕН}
5. Пришли к варианту, когда будем создавать обычный массив для базовых типов и массив указателей для TestClass. т.е. объект Array будет иметь два указателя, на обычный массив data, и на массив указателей dataP. Какой тип массива использовать будет определять конструктор Array(), второй массив будет пустым. т.е. имеем эффективное использвание памяти. {РАБОТАЕТ, НО} Работы с обычным массивом и масивом указателей происходит по разному. Т.е. для обработки двух типов массива потребуется два типа обработчиков в одном классе {ДУБЛИРОВАНИЕ КОДА, НЕХОРОШО}. Да и за указателями нужно внимательно смотреть, везде.
6. Возвращаемся к пункту 3. Как красиво, заменить int на T в нескольких местах кода, и массив Array быстро превращается в параметрический. А что если мы создадим внутрений массив, который будет хранить объекты-посредники. Посредник (Adapter) будет хранить указатель на объект типа T, при этом его размер будет равен размеру указателя. А обработка массива с адаптерами будет аналогична обработке массива базовых типов. Конечно, придется копировать адаптеры из массива в массив, но объекты типа T будут оставаться на своих местах в памяти. 

